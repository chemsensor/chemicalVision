# -*- coding: utf-8 -*-
"""
Created on Thu Jul 30 17:07:44 2020

@author: cantr
"""
#cap2 = cv2.VideoCapture(int(dictSet['CM2 en'][0]))
#ret, frame = cap2.read() 
#frameCrop2=frame2[dictSet['CM2 xy'][0]:dictSet['CM2 xy'][0]+dictSet['CM2 wh'][0],dictSet['CM2 xy'][1]:dictSet['CM2 xy'][1]+dictSet['CM2 wh'][1],:]

massFrame=frame2
hsvFrame = cv2.cvtColor(massFrame, cv2.COLOR_BGR2HSV)

dictSet['bal ll']=[0,50,220]
dictSet['bal ul']=[255,255,255]
massMask = cv2.inRange(hsvFrame, np.array([dictSet['bal ll']]), np.array(dictSet['bal ul'])) 
cv2.imshow('massMask',massMask)
outerBoxContour,boxArea,boxBoundingRectangle=FindLargestContour(massMask)
#cv2.drawContours(frame,[outerBoxContour],0,(0,255,0),2)
ptsFound = cv2.boxPoints(boxBoundingRectangle)

#epsilon = 0.1*cv2.arcLength(outerBoxContour,True)
#ptsFound = cv2.approxPolyDP(outerBoxContour,epsilon,True)

#box = np.int0(ptsFound)
#cv2.drawContours(frame,[box],0,(0,0,255),2)
#cv2.drawContours(frame,[ptsFound],0,(0,0,255),2)


dictSet['cl1 xy']=[300,100]
dictSet['cl2 xy']=[0,100]
dictSet['cl3 xy']=[0,0]
dictSet['cl4 xy']=[300,0]
orientation=1
ptsCard = np.float32([[dictSet['cl1 xy'][0],dictSet['cl1 xy'][1]],[dictSet['cl2 xy'][0],dictSet['cl2 xy'][1]],[dictSet['cl3 xy'][0],dictSet['cl3 xy'][1]],[dictSet['cl4 xy'][0],dictSet['cl4 xy'][1]]])
ptsImage = np.float32([[135,220],[765,220],[135,1095],[765,1095]]) 
if ptsFound.shape[0]==4:
    if orientation==1:
        ptsImage[0,0]=ptsFound[0,0]
        ptsImage[0,1]=ptsFound[0,1]
        ptsImage[1,0]=ptsFound[1,0]
        ptsImage[1,1]=ptsFound[1,1]
    else:
        ptsImage[1,0]=ptsFound[0,0]
        ptsImage[1,1]=ptsFound[0,1]
        ptsImage[0,0]=ptsFound[1,0]
        ptsImage[0,1]=ptsFound[1,1]
    if orientation==1:
        ptsImage[2,0]=ptsFound[2,0]
        ptsImage[2,1]=ptsFound[2,1]
        ptsImage[3,0]=ptsFound[3,0]
        ptsImage[3,1]=ptsFound[3,1]
    else:
        ptsImage[3,0]=ptsFound[2,0]
        ptsImage[3,1]=ptsFound[2,1]
        ptsImage[2,0]=ptsFound[3,0]
        ptsImage[2,1]=ptsFound[3,1]
    Mrot = cv2.getPerspectiveTransform(ptsImage,ptsCard)
    rotImage = cv2.warpPerspective(massFrame,Mrot,(300,100))


cv2.imshow('massFrame',massFrame)
rotImage = cv2.cvtColor(rotImage, cv2.COLOR_BGR2GRAY)
cv2.imshow('rotImage',rotImage)
digitHeight=85
digitWidth=45
imageStart=55
digits=np.zeros((digitHeight, digitWidth, 5), np.uint8)
total=0
for digit in range(5): 
    digits[:,:,digit]=rotImage[10:95,imageStart+(digit*digitWidth):imageStart+((digit+1)*digitWidth)]    
    cv2.imshow(str(digit),digits[:,:,digit])
    digitImage=digits[:,:,digit]
    dictSet['seg ll']=[0]
    dictSet['seg ul']=[150]
    digitMask = cv2.inRange(digitImage, np.array([dictSet['seg ll']]), np.array(dictSet['seg ul'])) 
    x,y,w,h = cv2.boundingRect(digitMask)
    if (w==0) and (h==0):
        decode=0
    elif h>w*3:
        decode=36
    else:
        decode=0
        digitMask=digitMask[y:y+h,x:x+w]
        cv2.imshow('MaskDigit'+str(digit),digitMask)
        dH=digitMask.shape[0]
        dW=digitMask.shape[1]
        
        ttSegment=digitMask[0:int(dH*0.15),int(dW*0.25):dW-int(dW*0.25)]
        ttOn = cv2.countNonZero(ttSegment)/ttSegment.size
        if ttOn>0.4:
            decode=decode+1
        cv2.imshow("top",ttSegment)
        
        tlSegment=digitMask[0:int(dH*0.45),0:int(dW*0.45)]
        tlOn = cv2.countNonZero(tlSegment)/tlSegment.size
        if tlOn>0.4:
            decode=decode+2
        cv2.imshow("top left",tlSegment)
        
        trSegment=digitMask[0:int(dH*0.45),dW-int(dW*0.45):dW]
        trOn = cv2.countNonZero(trSegment)/trSegment.size
        if trOn>0.4:
            decode=decode+4
        cv2.imshow("top right",trSegment)
        
        ccSegment=digitMask[int(dH/2)-int(dH*0.15):int(dH/2)+int(dH*0.15),int(dW*0.25):dW-int(dW*0.25)]
        ccOn = cv2.countNonZero(ccSegment)/ccSegment.size
        if ccOn>0.4:
            decode=decode+8
        cv2.imshow("center",ccSegment)
        
        blSegment=digitMask[dH-int(dH*0.45):dH,0:int(dW*0.45)]
        blOn = cv2.countNonZero(blSegment)/blSegment.size
        if blOn>0.4:
            decode=decode+16
        cv2.imshow("bottom left",blSegment)
        
        brSegment=digitMask[dH-int(dH*0.45):dH,dW-int(dW*0.45):dW]
        brOn = cv2.countNonZero(brSegment)/brSegment.size
        if brOn>0.4:
            decode=decode+32
        cv2.imshow("bottom right",brSegment)
        
        bbSegment=digitMask[dH-int(dH*0.15):dH,int(dW*0.25):dW-int(dW*0.25)]
        bbOn = cv2.countNonZero(bbSegment)/bbSegment.size
        if bbOn>0.4:
            decode=decode+64
        cv2.imshow("bottom",bbSegment)
    if decode==0:
        value=0
    elif decode==36:
        value=1
    elif decode==93:
        value=2
    elif decode==109:
        value=3
    elif decode==46:
        value=4
    elif decode==107:
        value=5
    elif decode==123:
        value=6
    elif decode==39:
        value=7
    elif decode==127:
        value=8
    elif decode==111:
        value=9
    else:
        value=-1
    print('digit '+str(digit)+' is '+str(bin(decode))+' value '+str(value))
    total=total+10**(2-digit)*value

print('displayed value = '+str(total))  
#edges = cv2.Canny(frame2,150,200)
#cv2.imshow('Edges',edges)

#cap2.release()
